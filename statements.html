<article><h4 id="walk">Домашнее задание 1. Обход файлов</h4><ol><li>
            Разработайте класс <code>Walk</code>, осуществляющий подсчет хэш-сумм файлов.
            <ol><li>
                    Формат запуска:
                    <pre>java Walk &lt;входной файл&gt; &lt;выходной файл&gt;</pre></li><li>
                    Входной файл содержит список файлов, которые требуется обойти.
                </li><li>
                    Выходной файл должен содержать по одной строке для каждого файла. 
                    Формат строки:
                    <pre>&lt;шестнадцатеричная хэш-сумма&gt; &lt;путь к файлу&gt;</pre></li><li>
                    Для подсчета хэш-суммы используйте
                    последние 64 бита <a href="https://en.wikipedia.org/wiki/SHA-256">SHA-256</a>
                    (поддержка есть в стандартной библиотеке).
                    
                </li><li>
                    Если при чтении файла возникают ошибки, укажите в качестве
                    его хэш-суммы все нули.
                </li><li>
                    Кодировка входного и выходного файлов — UTF-8.
                </li><li>
                    Размеры файлов могут превышать размер оперативной памяти.
                </li><li>
                    Пример
                    <table class="black"><tbody><tr><th>Входной файл</th></tr><tr><td><pre>samples/1
samples/12
samples/123
samples/1234
samples/1
samples/binary
samples/no-such-file
                        </pre></td></tr><tr><th>Выходной файл</th></tr><tr><td><pre>6b86b273ff34fce1 samples/1
6b51d431df5d7f14 samples/12
a665a45920422f9d samples/123
03ac674216f3e15c samples/1234
6b86b273ff34fce1 samples/1
40aff2e9d2d8922e samples/binary
0000000000000000 samples/no-such-file
                         </pre></td></tr></tbody></table></li></ol></li><li>
            Сложный вариант:
            <ol><li>
                    Разработайте класс <code>RecursiveWalk</code>,
                    осуществляющий подсчет хэш-сумм файлов в
                    директориях.
                </li><li>
                    Входной файл содержит список файлов и директорий,
                    которые требуется обойти. Обход директорий осуществляется
                    рекурсивно.
                </li><li>
                    Пример:
                    <table class="black"><tbody><tr><th>Входной файл</th></tr><tr><td><pre>samples/binary
samples
samples/no-such-file
                        </pre></td></tr><tr><th>Выходной файл</th></tr><tr><td><pre>40aff2e9d2d8922e samples/binary
6b86b273ff34fce1 samples/1
6b51d431df5d7f14 samples/12
a665a45920422f9d samples/123
03ac674216f3e15c samples/1234
40aff2e9d2d8922e samples/binary
0000000000000000 samples/no-such-file
                        </pre></td></tr></tbody></table></li></ol></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Дизайн и обработку исключений, диагностику ошибок.
                </li><li>
                    Программа должна корректно завершаться даже в случае ошибки.
                </li><li>
                    Корректная работа с вводом-выводом.
                </li><li>
                    Отсутствие утечки ресурсов.
                </li><li>
                    Возможность повторного использования кода.
                </li></ul></li><li>
            Требования к оформлению задания.
            <ul><li>
                    Проверяется исходный код задания.
                </li><li>
                    Весь код должен находиться в пакете
                    <code>info.kgeorgiy.ja.фамилия.walk</code>.
                </li></ul></li></ol><p><a href="https://www.kgeorgiy.info/git/geo/java-advanced-2025">Репозиторий курса</a></p><h4 id="arrayset">Домашнее задание 2. Множество на массиве</h4><ol><li>
            Разработайте класс <code>ArraySet</code>,
            реализующий неизменяемое упорядоченное множество.
            <ul><li>
                    Класс <code>ArraySet</code> должен реализовывать
                    интерфейс 
                    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SortedSet.html">SortedSet</a>
                    (простой вариант)
                    или 
                    <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/NavigableSet.html">NavigableSet</a> 
                    (сложный вариант).
                </li><li>
                    Все операции над множествами должны производиться с наилучшей асимптотической эффективностью.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    Применение стандартных коллекций.
                </li><li>
                    Избавление от повторяющегося кода.
                </li><li>
                    Отсутствие unchecked warnings при компиляции.
                </li><li>
                    Отсутствие излишних подавленных unchecked warnings.
                </li></ul></li></ol><h4 id="student">Домашнее задание 3. Студенты</h4><ol><li>
            Разработайте класс <code>StudentDB</code>,
            осуществляющий поиск по базе данных студентов.
            <ul><li>
                    Класс <code>StudentDB</code> должен реализовывать
                    интерфейс <code>StudentQuery</code> (простой вариант)
                    или <code>GroupQuery</code> (сложный вариант).
                </li><li>
                    Каждый метод должен состоять из ровно одного оператора.
                    При этом длинные операторы надо разбивать на несколько строк.
                </li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    применение лямбда-выражений и потоков;
                </li><li>
                    избавление от повторяющегося кода.
                </li></ul></li></ol><h4 id="lambda">Домашнее задание 4. Сплитераторы и коллекторы</h4><ol><li>
            Разработайте класс <code>Lambda</code>,
            реализующий сплитераторы для деревьев и дополнительные коллекторы.
            <ul><li><em>Простой вариант</em> (интерфейс <code>EasyLambda</code>) —
                    реализуйте:
                    <ul><li>
                            сплитераторы 
                            для двоичных деревьев, 
                            двоичных деревьев с известным размером,
                            k-ичных деревьев;
                        </li><li>
                            коллекторы первого, последнего, среднего элементов;
                        </li><li>
                            коллекторы общего префикса и суффикса строк.
                        </li></ul></li><li><em>Сложный вариант</em> (интерфейс <code>HardLambda</code>) —
                    дополнительно реализуйте:
                    <ul><li>
                            сплитераторы всех видов деревьев над списками элементов;
                        </li><li>
                            коллектор <var>n</var>-ого элемента;
                        </li><li>
                            коллекторы первых и последних <var>n</var> элементов.
                        </li></ul></li></ul></li><li>
            При выполнении задания следует обратить внимание на:
            <ul><li>
                    характеристики создаваемых сплитераторов;
                </li><li>
                    избавление от повторяющегося кода.
                </li></ul></li></ol><h4 id="implementor">Домашнее задание 5. Implementor</h4><ol><li>
            Реализуйте класс <code>Implementor</code>, 
            генерирующий реализации классов и интерфейсов.
            <ul><li>
                    Аргумент командной строки: полное имя класса/интерфейса, для
                    которого требуется сгенерировать реализацию.
                </li><li>
                    В результате работы должен быть сгенерирован java-код класса с суффиксом
                    <code>Impl</code>, расширяющий (реализующий) указанный класс (интерфейс).
                </li><li>
                    Сгенерированный класс должен компилироваться без ошибок.
                </li><li>
                    Сгенерированный класс не должен быть абстрактным.
                </li><li>
                    Методы сгенерированного класса должны игнорировать свои аргументы и
                    возвращать значения по умолчанию.
                </li></ul></li><li>
            В задании выделяются три варианта:
            <ul><li><em>Простой</em> — <code>Implementor</code> должен уметь реализовывать
                    только интерфейсы (но не классы). Поддержка generics не требуется.
                </li><li><em>Сложный</em> — <code>Implementor</code> должен уметь реализовывать
                    и классы, и интерфейсы. Поддержка generics не требуется.
                </li><li><em>Бонусный</em> — <code>Implementor</code> должен уметь реализовывать
                    generic-классы и интерфейсы. Сгенерированный код должен иметь
                    корректные параметры типов и не порождать unchecked warnings.
                </li></ul></li></ol><h4 id="implementor-jar">Домашнее задание 6. Jar Implementor</h4><p>
        Это домашнее задание <b>связано</b> с предыдущим
        и будет приниматься только с ним.
        Предыдущее домашнее задание отдельно сдать будет нельзя.
    </p><ol><li>
            Создайте <code>.jar</code>-файл, содержащий скомпилированный
            <code>Implementor</code> и сопутствующие классы.
            <ul><li>
                    Созданный <code>.jar</code>-файл должен запускаться командой
                    <code>java -jar</code>.
                </li><li>
                    Запускаемый <code>.jar</code>-файл должен принимать те же аргументы командной
                    строки, что и класс <code>Implementor</code>.
                </li></ul></li><li>
            Модифицируйте <code>Implementor</code> так, чтобы
            при запуске с аргументами <code>-jar имя-класса файл.jar</code>
            он генерировал <code>.jar</code>-файл с реализацией
            соответствующего класса (интерфейса).
            Для компиляции можно использовать код из тестов.
        </li><li>
            Вы можете создавать файлы и директории в текущем каталоге,
            но не за его пределами.
        </li><li>
            Для проверки, кроме исходного кода, также должны быть представлены:
            <ul><li>
                    скрипт для создания запускаемого <code>.jar</code>-файла, 
                    в том числе, исходный код манифеста;
                </li><li>
                    запускаемый <code>.jar</code>-файл.
                </li></ul></li><li><b>Сложный вариант</b>. Решение должно быть модуляризовано.
        </li></ol><h4 id="implementor-javadoc">Домашнее задание 7. Javadoc</h4><p>
        Это домашнее задание <b>связано</b> с двумя предыдущими
        и будет приниматься только с ними.
        Предыдущие домашнее задание отдельно сдать будет нельзя.
    </p><ol><li>
            Документируйте класс <code>Implementor</code> и сопутствующие классы 
            с применением Javadoc.
            <ul><li>
                    Должны быть документированы все классы и все члены классов, 
                    в том числе <code>private</code>.
                </li><li>
                    Документация должна генерироваться без предупреждений.
                </li><li>
                    Сгенерированная документация должна содержать корректные 
                    ссылки на классы стандартной библиотеки и модулей
                    <code>info.kgeorgiy.java.advanced.*</code>.
                </li></ul></li><li>
            Для проверки, кроме исходного кода, также должны быть представлены:
            <ul><li>
                    скрипт для генерации документации 
                    (он может рассчитывать, что рядом с вашим репозиторием 
                    склонирован репозиторий курса);
                </li><li>
                    сгенерированная документация.
                </li></ul></li></ol><p>
        В <b>последующих</b> домашних заданиях все <code>public</code> и 
        <code>protected</code> сущности должны быть документированы.
    </p><h4 id="concurrent">Домашнее задание 8. Итеративный параллелизм</h4><ol><li>
            Реализуйте класс <code>IterativeParallelism</code>,
            который будет обрабатывать списки в несколько потоков.
        </li><li>
            В простом варианте должны быть реализованы следующие методы:
            <ul><li><code>argMax(threads, list, comparator)</code> —
                    индекс первого максимума;
                </li><li><code>argMin(threads, list, comparator)</code> —
                    индекс первого минимума;
                </li><li><code>indexOf(threads, list, predicate)</code> —
                    индекс первого элемента, удовлетворяющего предикат;
                </li><li><code>lastIndexOf(threads, list, predicate)</code> —
                    индекс последнего элемента, удовлетворяющего предикат;
                </li><li><code>sumIndices(threads, list, predicate)</code> —
                    сумма индексов элементов, удовлетворяющих предикат;
                </li></ul></li><li>
            В сложном варианте должны быть дополнительно реализованы следующие методы:
            <ul><li><code>indices(threads, list, predicate)</code> —
                    индексы элементов, удовлетворяющих предикат;
                </li><li><code>filter(threads, list, predicate)</code> —
                    вернуть список, содержащий элементы удовлетворяющие предикату;
                </li><li><code>map(threads, list, function)</code> —
                    вернуть список, содержащий результаты применения функции;
                </li></ul></li><li>
            Во все функции передается параметр <code>threads</code> —
            сколько потоков надо использовать при вычислении.
            Вы можете рассчитывать, что число потоков относительно мало.
        </li><li>
            Не следует рассчитывать на то, что переданные компараторы,
            предикаты и функции работают быстро.
        </li><li>
            Можно сделать O(<code>threads</code>), но не O(<code>list.size()</code>) 
            действий без распараллеливания.
        </li><li>
            При выполнении задания <strong>нельзя</strong> использовать
            <i>Concurrency Utilities</i> и <i>Parallel Streams</i>.
        </li></ol><h4 id="mapper">Домашнее задание 9. Параллельный запуск</h4><ol><li>
            Напишите класс <code>ParallelMapperImpl</code>, реализующий интерфейс
            <code>ParallelMapper</code>.
<pre>public interface ParallelMapper extends AutoCloseable {
    &lt;T, R&gt; List&lt;R&gt; map(
        Function&lt;? super T, ? extends R&gt; f,
        List&lt;? extends T&gt; args
    ) throws InterruptedException;

    @Override
    void close();
}
</pre><ul><li>
                    Метод <code>map</code> должен параллельно вычислять
                    функцию <code>f</code> на каждом из указанных аргументов
                    (<code>args</code>).
                </li><li>
                    Конструктор <code>ParallelMapperImpl(int threads)</code>
                    должен создавать <code>threads</code> рабочих потоков, 
                    которые используются для распараллеливания.
                </li><li>
                    Метод <code>close</code> должен останавливать все рабочие потоки.
                </li><li>
                    К одному <code>ParallelMapperImpl</code> 
                    могут одновременно обращаться несколько клиентов.
                </li><li>
                    При недостатке потоков для распараллеливания, 
                    задания на исполнение должны накапливаться в очереди и
                    обрабатываться в порядке поступления.
                </li><li>
                    В реализации не должно быть активных ожиданий.
                </li><li>Код должен находиться в пакете <code>iterative</code>.</li><li>
                    Обратите внимание на обработку исключений, 
                    кидаемых функцией <code>f</code>.
                    <ol><li>
                            Исключения не должны приводить к сокращению числа
                            рабочих потоков.
                        </li><li><b>Сложный вариант.</b>
                            Исключения должны выкидываться из метода <code>map</code>.
                        </li></ol></li></ul></li><li>
            Доработайте класс <code>IterativeParallelism</code> так,
            чтобы он мог использовать <code>ParallelMapper</code>.
            <ul><li>
                    Добавьте конструктор <code>IterativeParallelism(ParallelMapper)</code>.
                </li><li>
                    Методы класса должны делить работу на <code>threads</code>
                    фрагментов и исполнять их при помощи <code>ParallelMapper</code>.
                </li><li>
                    При наличии <code>ParallelMapper</code> сам
                    <code>IterativeParallelism</code> новые потоки создавать не должен.
                </li><li>
                    Должна быть возможность одновременного запуска и работы
                    нескольких клиентов, использующих один <code>ParallelMapper</code>.
                </li></ul></li><li>
            При выполнении задания всё ещё <strong>нельзя</strong> использовать
            <i>Concurrency Utilities</i> и <i>Parallel Streams</i>.
        </li></ol><h4 id="crawler">Домашнее задание 10. Web Crawler</h4><ol><li>
            Напишите потокобезопасный класс <code>WebCrawler</code>, который
            будет рекурсивно обходить сайты.
            <ol><li>
                    Класс <code>WebCrawler</code> должен иметь конструктор
<pre>public WebCrawler(Downloader downloader, int downloaders, int extractors, int perHost)
</pre><ul><li><code>downloader</code> позволяет скачивать страницы и
                            извлекать из них ссылки;
                        </li><li><code>downloaders</code> — максимальное число
                            одновременно загружаемых страниц;
                        </li><li><code>extractors</code> — максимальное число страниц,
                            из которых одновременно извлекаются ссылки;
                        </li><li><code>perHost</code> — максимальное число страниц,
                            одновременно загружаемых c одного хоста.
                            Для определения хоста следует использовать
                            метод <code>getHost</code> класса
                            <code>URLUtils</code> из тестов.
                        </li></ul></li><li>
                    Класс <code>WebCrawler</code> должен реализовывать интерфейс
                    <code>Crawler</code><pre>public interface Crawler extends AutoCloseable {
    Result download(String url, int depth);

    void close();
}
</pre><ul><li>
                            Метод <code>download</code> должен 
                            рекурсивно обходить страницы, начиная с указанного URL, 
                            на указанную глубину и возвращать 
                            список загруженных страниц и файлов.

                            Например, если глубина равна 1, то должна быть
                            загружена только указанная страница. 
                            Если глубина равна 2, то указанная страница 
                            и те страницы и файлы, на которые
                            она ссылается, и так далее.
                        </li><li>
                            Метод <code>download</code> может вызываться 
                            параллельно в нескольких потоках.
                        </li><li>
                            Загрузка и обработка страниц (извлечение ссылок)
                            должна выполняться максимально параллельно,
                            с учетом ограничений на число одновременно
                            загружаемых страниц (в том числе с одного хоста)
                            и страниц, с которых загружаются ссылки.
                        </li><li>
                            Для распараллеливания разрешается создать
                            <code>downloaders + extractors</code>
                            вспомогательных потоков.
                        </li><li>
                            Повторно загружать и/или извлекать ссылки из одной
                            и той же страницы в рамках одного обхода
                            (<code>download</code>) запрещается.
                        </li><li>
                            Метод <code>close</code> должен завершать все
                            вспомогательные потоки.
                        </li></ul></li><li>
                    Для загрузки страниц должен применяться <code>Downloader</code>,
                    передаваемый первым аргументом конструктора.
<pre>public interface Downloader {
    public Document download(final String url) throws IOException;
}
</pre><ul><li>
                            Метод <code>download</code> загружает документ по его адресу
                            (<a href="http://tools.ietf.org/html/rfc3986">URL</a>).
                        </li><li>
                            Документ позволяет получить ссылки по загруженной странице:
<pre>public interface Document {
    List&lt;String&gt; extractLinks() throws IOException;
}
</pre>
                            Ссылки, возвращаемые документом, являются абсолютными
                            и имеют схему <code>http</code> или <code>https</code>.
                        </li></ul></li><li>
                    Должен быть реализован метод <code>main</code>,
                    позволяющий запустить обход из командной строки
                    <ul><li>
                            Командная строка
<pre>WebCrawler url [depth [downloaders [extractors [perHost]]]]
</pre></li><li>
                            Для загрузки страниц требуется использовать реализацию
                            <code>CachingDownloader</code> из тестов.
                        </li></ul></li></ol></li><li>
            Версии задания
            <ol><li><em>Простая</em> — не требуется учитывать ограничения
                    на число одновременных закачек с одного хоста
                    (<code>perHost &gt;= downloaders</code>).
                </li><li><em>Полная</em> — требуется учитывать все ограничения.
                </li><li><em>Бонусная</em> — сделать параллельный обход в ширину.
                </li></ol></li><li>
            Задание подразумевает активное использование Concurrency Utilities,
            в частности, в решении не должно быть «велосипедов»,
            аналогичных/легко сводящихся к классам из Concurrency Utilities.
        </li></ol><h4 id="hello-udp">Домашнее задание 11. HelloUDP</h4><ol><li>
            Реализуйте клиент и сервер, взаимодействующие по UDP.
        </li><li>
            Класс <tt>HelloUDPClient</tt> должен отправлять запросы
            на сервер, принимать результаты и выводить их на консоль.
            <ul><li>
                    Аргументы командной строки:
                    <ol><li>имя или ip-адрес компьютера, на котором запущен сервер;</li><li>номер порта, на который отсылать запросы;</li><li>префикс запросов (строка);</li><li>число параллельных потоков запросов;</li><li>число запросов в каждом потоке.</li></ol></li><li>
                    Запросы должны одновременно отсылаться в указанном числе потоков.
                    Каждый поток должен ожидать обработки своего запроса и выводить
                    сам запрос и результат его обработки на консоль.
                    Если запрос не был обработан, требуется послать его заново.
                </li><li>
                    Запросы должны формироваться по схеме
                    <tt>&lt;префикс запросов&gt;&lt;номер запроса в потоке&gt;_&lt;номер потока&gt;</tt>.
                </li></ul></li><li>
            Класс <tt>HelloUDPServer</tt> должен принимать задания, отсылаемые
            классом <tt>HelloUDPClient</tt> и отвечать на них.
            <ul><li>
                    Аргументы командной строки:
                    <ol><li>номер порта, по которому будут приниматься запросы;</li><li>число рабочих потоков, которые будут обрабатывать запросы.</li></ol></li><li>
                    Ответом на запрос должно быть <tt>Hello, &lt;текст запроса&gt;</tt>.
                </li><li>
                    Несмотря на то, что текущий способ получения ответа по запросу
                    очень прост, сервер должен быть рассчитан на ситуацию, 
                    когда этот процесс может требовать много ресурсов и времени.
                </li><li>
                    Если сервер не успевает обрабатывать запросы, прием запросов может
                    быть временно приостановлен.
                </li></ul></li></ol><h4 id="bank">Домашнее задание 12. Физические лица</h4><ol><li>
            Добавьте к банковскому приложению возможность работы с физическими
            лицами.
            <ol><li>
                    У физического лица (<code>Person</code>) можно запросить 
                    имя, фамилию и номер паспорта.
                </li><li>
                    Удалённые физические лица (<code>RemotePerson</code>) 
                    должны передаваться при помощи удалённых объектов.
                </li><li>
                    Локальные физические лица (<code>LocalPerson</code>) 
                    должны передаваться при помощи механизма сериализации,
                    и при последующем использовании не требовать связи с сервером.
                </li><li>
                    Должна быть возможность поиска физического лица по
                    номеру паспорта, с выбором типа возвращаемого лица.
                </li><li>
                    Должна быть возможность создания записи о физическом лице 
                    по его данным.
                </li></ol></li><li>
                У физического лица может быть несколько счетов, 
                к которым должен предоставляться доступ
                через <code>Person</code>.
            </li><ol><li>
                    Счёту физического лица с идентификатором <var>subId</var>
                    должен соответствовать банковский счёт с <var>id</var>
                    вида <var>personId</var>:<var>subId</var>.
                </li><li>
                    Изменения, производимые со счётом в банке
                    (создание и изменение баланса), должны быть видны всем
                    соответствующим <code>RemotePerson</code>, 
                    и только тем <code>LocalPerson</code>, 
                    которые были созданы после этого изменения.
                </li><li>
                    Изменения в счетах, производимые через <code>RemotePerson</code>,
                    должны сразу применяться глобально, а производимые
                    через <code>LocalPerson</code> – только локально
                    для этого конкретного <code>LocalPerson</code>.
                </li></ol><li>
            Реализуйте приложение, демонстрирующее работу с физическим лицами.
            <ol><li>
                    Аргументы командной строки: имя, фамилия, номер паспорта физического
                    лица, номер счёта, изменение суммы счёта.
                </li><li>
                    Если информация об указанном физическом лице отсутствует, то оно должно
                    быть добавлено. В противном случае – должны быть проверены его данные.
                </li><li>
                    Если у физического лица отсутствует счёт с указанным номером, то
                    он создается с нулевым балансом.
                </li><li>
                    После обновления суммы счёта новый баланс должен выводиться на консоль.
                </li></ol></li><li><b>Сложный вариант</b><ol><li>
                    На каждом счету всегда должно быть 
                    неотрицательное количество денег.
                </li></ol></li><li>
            Приложение должно находиться в пакете
            <code>info.kgeorgiy.ja.*.bank</code> и его подпакетах.
        </li></ol><h4 id="bank-test">Домашнее задание 13. Физические лица (тесты)</h4><ol><li>
            Напишите тесты, проверяющие поведение банка и приложения
            из домашнего задания <a href="#bank">Физические лица</a>.
            <ul><li>
                    Для реализации тестов рекомендуется использовать
                    <a href="https://junit.org/junit5/">JUnit</a>
                    (<a href="https://www.petrikainulainen.net/programming/testing/junit-5-tutorial-writing-our-first-test-class/">Tutorial</a>).
                    Множество примеров использования можно найти в тестах.
                </li><li>
                    Если вы знакомы с другим тестовым фреймворком
                    (например, <a href="https://testng.org/">TestNG</a>),
                    то можете использовать его.
                </li><li>
                    Добавьте jar-файлы используемых библиотек в каталог 
                    <code>lib</code> вашего репозитория.
                </li><li><em>Нельзя</em> использовать самописные фреймворки и тесты,
                    запускаемые через <code>main</code>.
                </li></ul></li><li><b>Сложный вариант</b><ol><li>
                    Тесты не должны рассчитывать на наличие запущенного
                    RMI Registry.
                </li><li>
                    Создайте класс <code>BankTests</code>, запускающий тесты.
                </li><li>
                    Создайте скрипт, запускающий <code>BankTests</code>
                    и возвращающий код (статус) <code>0</code>
                    в случае успеха и <code>1</code> в случае неудачи.
                </li><li>
                    Создайте скрипт, запускающий тесты с использованием
                    стандартного подхода для вашего тестового фреймворка.
                    Код возврата должен быть как в предыдущем пункте.
                </li></ol></li><li>
            Тесты должны находиться в пакете
            <code>info.kgeorgiy.ja.*.bank</code> и его подпакетах.
        </li><li>
            При сдаче вам нужно будет продемонстрировать работу тестов
            на вашем компьютере.
        </li></ol><p>
        Это домашнее задание <b>связано</b> с
        домашним заданием <a href="#bank">Физические лица</a>
        и будет приниматься только с ним.
    </p><h4 id="hello-nb">Домашнее задание 14. HelloNonblockingUDP</h4><ol><li>
            Реализуйте клиент и сервер, взаимодействующие по UDP,
            используя только неблокирующий ввод-вывод.
        </li><li>
            Класс <code>HelloUDPNonblockingClient</code> должен
            иметь функциональность аналогичную <code>HelloUDPClient</code>,
            но без создания новых потоков.
        </li><li>
            Класс <code>HelloUDPNonblockingServer</code> должен
            иметь функциональность аналогичную <code>HelloUDPServer</code>,
            но все операции с сокетом должны производиться в одном потоке.
        </li><li>
            В реализации не должно быть активных ожиданий,
            в том числе через <code>Selector</code>.
        </li><li>
            Обратите внимание на выделение общего кода старой и новой реализации.
        </li><li>
            Можно использовать неблокирующий или асинхронный ввод-вывод.
            Нельзя использовать виртуальные потоки.
        </li><li><em>Бонусный вариант</em>.
            Клиент и сервер могут перед началом работы выделить
            <em>O(число рабочих потоков)</em> памяти.
            Выделять дополнительную память во время работы запрещено.
        </li></ol><h4 id="text-stats">Домашнее задание 15. Статистика текста</h4><ol><li>
            Создайте приложение <code>TextStatistics</code>,
            анализирующее тексты на различных языках.
            <ol><li>
                    Аргументы командной строки:
                    <ul><li>локаль текста,</li><li>локаль вывода,</li><li>файл с текстом,</li><li>файл отчета.</li></ul></li><li>
                    Поддерживаемые локали текста: все локали, имеющиеся в системе.
                </li><li>
                    Поддерживаемые локали вывода: русская и английская.
                </li><li>
                    Файлы имеют кодировку UTF-8.
                </li><li>
                    Подсчет статистики должен вестись по следующим категориям:
                    <ul><li>предложения,</li><li>слова,</li><li>числа,</li><li>деньги,</li><li>даты.</li></ul></li><li>
                    Для каждой категории должна собираться следующая статистика:
                    <ul><li>число вхождений,</li><li>число различных значений,</li><li>минимальное значение,</li><li>максимальное значение,</li><li>минимальная длина,</li><li>максимальная длина,</li><li>среднее значение/длина.</li></ul></li><li>
                    Пример отчета:
<pre>Анализируемый файл "quine.ru-RU.in".
Сводная статистика
    Число предложений: 30.
    Число слов: 117.
    Число чисел: 35.
    Число сумм: 3.
    Число дат: 3.
Статистика по предложениям
    Число предложений: 30 (30 различных).
    Минимальное предложение: "Анализируемый файл "quine.ru-RU.in".".
    Максимальное предложение: "Число чисел: 35.".
    Минимальная длина предложения: 13 ("Число дат: 3.").
    Максимальная длина предложения: 109 ("GK: если сюда поставить реальное предложение, то процесс не сойдётся").
    Средняя длина предложения: 37,7.
Статистика по словам
    Число слов: 117 (48 различных).
    Минимальное слово: "GK".
    Максимальное слово: "языках".
    Минимальная длина слова: 1 ("с").
    Максимальная длина слова: 18 ("TextStatisticsTest").
    Средняя длина слова: 6,752.
Статистика по числам
    Число чисел: 35 (21 различных).
    Минимальное число: -12345,67.
    Максимальное число: 12345,67.
    Среднее число: 221,381.
Статистика по суммам денег
    Число сумм: 3 (3 различных).
    Минимальная сумма: 100,00&nbsp;₽.
    Максимальная сумма: 345,67&nbsp;₽.
    Средняя сумма: 222,83&nbsp;₽.
Статистика по датам
    Число дат: 3 (3 различных).
    Минимальная дата: 23 мая 2025 г..
    Максимальная дата: 30 мая 2025 г..
    Средняя дата: 26 мая 2025 г..
</pre></li></ol></li><li>
            Вы можете рассчитывать на то, что весь текст помещается в память.
        </li><li>
            При выполнении задания следует обратить внимание на:
            <ol><li>Декомпозицию сообщений для локализации.</li><li>Согласование сообщений по роду и числу.</li></ol></li><li>
            Приложение должно находиться в пакете
            <code>info.kgeorgiy.ja.*.i18n</code> и его подпакетах.
        </li></ol></article>
